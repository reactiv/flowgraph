<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8">

<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Curie Omni | Workflow Graph Studio</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="Curie Omni" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Building heterogeneous workflows through context graphs and agentic transformation" />
<meta property="og:description" content="Building heterogeneous workflows through context graphs and agentic transformation" />
<link rel="canonical" href="http://0.0.0.0:4000/" />
<meta property="og:url" content="http://0.0.0.0:4000/" />
<meta property="og:site_name" content="Workflow Graph Studio" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Curie Omni" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebSite","description":"Building heterogeneous workflows through context graphs and agentic transformation","headline":"Curie Omni","name":"Workflow Graph Studio","url":"http://0.0.0.0:4000/"}</script>
<!-- End Jekyll SEO tag -->

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="preload" href="https://fonts.googleapis.com/css?family=Open+Sans:400,700&display=swap" as="style" type="text/css" crossorigin>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#157878">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
<script>
  document.addEventListener('DOMContentLoaded', function() {
    mermaid.initialize({
      startOnLoad: true,
      theme: 'neutral',
      flowchart: {
        useMaxWidth: true,
        htmlLabels: true,
        curve: 'basis'
      }
    });
  });
</script>

  </head>
  <body>
    <a id="skip-to-content" href="#content">Skip to the content.</a>

    <header class="page-header" role="banner">
      <h1 class="project-name">Curie Omni</h1>
      <h2 class="project-tagline">Building heterogeneous workflows through context graphs and agentic transformation</h2>
      
        <a href="https://github.com/reactivy/papeete" class="btn">View on GitHub</a>
      
      
    </header>

    <main id="content" class="main-content" role="main">
      <script type="module">
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
  mermaid.initialize({ startOnLoad: false, theme: 'neutral' });

  document.addEventListener('DOMContentLoaded', async () => {
    // Find all mermaid code blocks
    const codeBlocks = document.querySelectorAll('pre code.language-mermaid');
    codeBlocks.forEach(block => {
      const pre = block.parentElement;
      const div = document.createElement('div');
      div.className = 'mermaid';
      div.textContent = block.textContent;
      pre.replaceWith(div);
    });
    await mermaid.run();
  });
</script>

<h1 id="curie-omni">Curie Omni</h1>

<p><strong>Building heterogeneous workflows through context graphs and agentic transformation</strong></p>

<hr />

<h2 id="the-challenge-scaling-beyond-single-purpose-tools">The Challenge: Scaling Beyond Single-Purpose Tools</h2>

<p>Curie demonstrates that purpose-built workflow tools can dramatically accelerate scientific research. But every new domain‚Äîmaterials science, drug discovery, clinical trials‚Äîrequires building a new tool from scratch.</p>

<p>We ask ourselves: <strong>How do we build just one tool, to enable agentic capabilities across ALL workflows?</strong></p>

<p>Instead of building N separate tools for N workflows, we wanted to build a single system where:</p>

<ul>
  <li><strong>Features benefit many workflows</strong>: A better Kanban view or state machine helps everyone</li>
  <li><strong>Heterogeneity is a design principle</strong>: Workflows differ wildly, and that‚Äôs fine</li>
  <li><strong>Team effort decouples from value growth</strong>: The platform gets smarter without linear engineering time</li>
</ul>

<p>The result is <strong>Curie Omni</strong>‚Äîa prototype demonstrating that ‚Äúany workflow is just a graph.‚Äù</p>

<hr />

<h2 id="core-insight-context-graphs-as-dags">Core Insight: Context Graphs as DAGs</h2>

<p>The key realisation is that workflows, regardless of domain, share a common structure: <strong>directed graphs of typed nodes connected by typed edges</strong>.</p>

<h3 id="two-graphs-one-system">Two Graphs, One System</h3>

<p>Every workflow in our system consists of two complementary graphs:</p>

<table>
  <thead>
    <tr>
      <th>Graph</th>
      <th>Purpose</th>
      <th>Example</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Schema Graph</strong></td>
      <td>Defines what‚Äôs <em>possible</em>‚Äînode types, edge types, field definitions, state machines</td>
      <td>‚ÄúA Sample can have Analyses. Analyses can be Complete or Failed.‚Äù</td>
    </tr>
    <tr>
      <td><strong>Instance Graph</strong></td>
      <td>Holds what <em>exists</em>‚Äîactual nodes, edges, and events</td>
      <td>‚ÄúSample S-001 has Analysis A-042, which is Complete.‚Äù</td>
    </tr>
  </tbody>
</table>

<h3 id="anatomy-of-a-context-graph">Anatomy of a Context Graph</h3>

<p><strong>Schema Graph</strong> ‚Äî defines what‚Äôs possible:</p>

<pre><code class="language-mermaid">graph LR
    subgraph Schema["Schema Graph"]
        Sample([Sample])
        Analysis([Analysis])
        InstrConfig([InstrConfig])

        Sample --&gt;|HAS_ANALYSIS| Analysis
        Sample --&gt;|PARENT_OF| Sample
        Analysis --&gt;|USES_CONFIG| InstrConfig
    end

    style Sample fill:#e1f5fe
    style Analysis fill:#fff3e0
    style InstrConfig fill:#f3e5f5
</code></pre>

<p><strong>Instance Graph</strong> ‚Äî holds what exists:</p>

<pre><code class="language-mermaid">graph LR
    subgraph Instance["Instance Graph"]
        S001["S-001&lt;br/&gt;&lt;small&gt;Complete&lt;/small&gt;"]
        S003["S-003&lt;br/&gt;&lt;small&gt;Draft&lt;/small&gt;"]
        A042["A-042&lt;br/&gt;&lt;small&gt;Complete&lt;/small&gt;"]
        XRD["XRD-Setup"]

        S001 --&gt;|HAS_ANALYSIS| A042
        S001 --&gt;|PARENT_OF| S003
        A042 --&gt;|USES_CONFIG| XRD
    end

    style S001 fill:#c8e6c9
    style S003 fill:#ffecb3
    style A042 fill:#c8e6c9
    style XRD fill:#e1bee7
</code></pre>

<h3 id="node-types-define-structure">Node Types Define Structure</h3>

<p>Each node type in the schema specifies:</p>

<ul>
  <li><strong>Fields</strong>: Typed properties (<code class="language-plaintext highlighter-rouge">string</code>, <code class="language-plaintext highlighter-rouge">number</code>, <code class="language-plaintext highlighter-rouge">datetime</code>, <code class="language-plaintext highlighter-rouge">enum</code>, <code class="language-plaintext highlighter-rouge">person</code>, <code class="language-plaintext highlighter-rouge">json</code>, <code class="language-plaintext highlighter-rouge">tag[]</code>, <code class="language-plaintext highlighter-rouge">file[]</code>)</li>
  <li><strong>States</strong>: Optional state machine with allowed transitions</li>
  <li><strong>UI Hints</strong>: Quick actions, colors, display preferences</li>
</ul>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"id"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Sample"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Sample"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"fields"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
    </span><span class="p">{</span><span class="nl">"id"</span><span class="p">:</span><span class="w"> </span><span class="s2">"sample_id"</span><span class="p">,</span><span class="w"> </span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Sample ID"</span><span class="p">,</span><span class="w"> </span><span class="nl">"kind"</span><span class="p">:</span><span class="w"> </span><span class="s2">"string"</span><span class="p">,</span><span class="w"> </span><span class="nl">"required"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="p">},</span><span class="w">
    </span><span class="p">{</span><span class="nl">"id"</span><span class="p">:</span><span class="w"> </span><span class="s2">"created_date"</span><span class="p">,</span><span class="w"> </span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Date Created"</span><span class="p">,</span><span class="w"> </span><span class="nl">"kind"</span><span class="p">:</span><span class="w"> </span><span class="s2">"datetime"</span><span class="p">},</span><span class="w">
    </span><span class="p">{</span><span class="nl">"id"</span><span class="p">:</span><span class="w"> </span><span class="s2">"sample_type"</span><span class="p">,</span><span class="w"> </span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Type"</span><span class="p">,</span><span class="w"> </span><span class="nl">"kind"</span><span class="p">:</span><span class="w"> </span><span class="s2">"enum"</span><span class="p">,</span><span class="w">
     </span><span class="nl">"options"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">"synth"</span><span class="p">,</span><span class="w"> </span><span class="s2">"post_synth"</span><span class="p">,</span><span class="w"> </span><span class="s2">"analysis"</span><span class="p">,</span><span class="w"> </span><span class="s2">"commercial"</span><span class="p">]}</span><span class="w">
  </span><span class="p">],</span><span class="w">
  </span><span class="nl">"states"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"enabled"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w">
    </span><span class="nl">"initial"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Draft"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"values"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">"Draft"</span><span class="p">,</span><span class="w"> </span><span class="s2">"In Progress"</span><span class="p">,</span><span class="w"> </span><span class="s2">"Complete"</span><span class="p">,</span><span class="w"> </span><span class="s2">"Archived"</span><span class="p">],</span><span class="w">
    </span><span class="nl">"transitions"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
      </span><span class="p">{</span><span class="nl">"from"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Draft"</span><span class="p">,</span><span class="w"> </span><span class="nl">"to"</span><span class="p">:</span><span class="w"> </span><span class="s2">"In Progress"</span><span class="p">},</span><span class="w">
      </span><span class="p">{</span><span class="nl">"from"</span><span class="p">:</span><span class="w"> </span><span class="s2">"In Progress"</span><span class="p">,</span><span class="w"> </span><span class="nl">"to"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Complete"</span><span class="p">},</span><span class="w">
      </span><span class="p">{</span><span class="nl">"from"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Complete"</span><span class="p">,</span><span class="w"> </span><span class="nl">"to"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Archived"</span><span class="p">}</span><span class="w">
    </span><span class="p">]</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<h3 id="edge-types-define-relationships">Edge Types Define Relationships</h3>

<p>Edges are first-class citizens with their own properties:</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"id"</span><span class="p">:</span><span class="w"> </span><span class="s2">"HAS_ANALYSIS"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Has Analysis"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"from"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Sample"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"to"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Analysis"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"properties"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
    </span><span class="p">{</span><span class="nl">"id"</span><span class="p">:</span><span class="w"> </span><span class="s2">"performed_by"</span><span class="p">,</span><span class="w"> </span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Performed By"</span><span class="p">,</span><span class="w"> </span><span class="nl">"kind"</span><span class="p">:</span><span class="w"> </span><span class="s2">"person"</span><span class="p">}</span><span class="w">
  </span><span class="p">]</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<hr />

<h2 id="agentic-transformer-teaching-the-platform-to-learn">Agentic Transformer: Teaching the Platform to Learn</h2>

<p>The second core component is the <strong>Agentic Transformer</strong>‚Äîa system that uses Claude SDK agents in a validation loop to generate transformation code.</p>

<h3 id="why-transformation-matters">Why Transformation Matters</h3>

<p>Functions are the most important abstraction in programming, given a particular input, reliably produce some kind of output. 
Coding agents have drastically reduced the amount of oversight required to generate even complex data transformations, which would otherwise have taken
engineers hours to days to create and validate. 
A recent paradigm is the creation of so called ‚ÄúRalph Wiggum‚Äù (yes from the Simpsons), loops, where an agent is repeatedly called until some validation
threshold has passed. This is where agents shine the most, rigorously define what the success criteria are, and then let it find its own way.</p>

<p>The ability to learn functions greatly reduces the amount of customisation that is required to onboard any new workflow, which inevitably come with 
their own bespoke input formats, 3rd party data systems and other challenges. This context fragmentation is a fact of life, and a major blocker for 
greater uptake of AI for other types of knowledge work.</p>

<p>Rather than our developers writing one-off scripts, the Agentic Transformer:</p>

<ol>
  <li><strong>Takes instructions in natural language</strong>: ‚ÄúImport samples from this spreadsheet‚Äù</li>
  <li><strong>Explores the input</strong>: Reads files, queries APIs, understands structure</li>
  <li><strong>Generates transformation code</strong>: Python scripts that produce valid output</li>
  <li><strong>Validates</strong>: Pydantic models catch errors before they propagate, as well as any custom validation code or even LLM as judge patterns</li>
  <li><strong>Optionally learns</strong>: Saves reusable skills for future runs</li>
</ol>

<h3 id="the-validation-loop">The Validation Loop</h3>

<pre><code class="language-mermaid">flowchart TB
    subgraph Transformer["Agentic Transformer"]
        Input["üìÅ Input Files"]
        Agent["ü§ñ Claude Agent"]
        Code["transform.py&lt;br/&gt;&lt;small&gt;(generated)&lt;/small&gt;"]
        Execute["‚ö° Execute"]

        subgraph Validation["Multi-Layer Validation"]
            Schema["Schema&lt;br/&gt;&lt;small&gt;(Pydantic)&lt;/small&gt;"]
            Custom["Custom&lt;br/&gt;&lt;small&gt;(optional)&lt;/small&gt;"]
            LLM["LLM-as-Judge&lt;br/&gt;&lt;small&gt;(optional)&lt;/small&gt;"]
        end

        Output["üì§ Output JSON"]

        Input --&gt; Agent
        Agent --&gt; Code
        Code --&gt; Execute
        Execute --&gt; Schema
        Schema -.-&gt; Custom
        Custom -.-&gt; LLM
        Schema --&gt;|"‚ùå errors"| Agent
        LLM --&gt;|"‚ùå errors"| Agent
        LLM --&gt;|"‚úÖ valid"| Output
        Schema --&gt;|"‚úÖ valid"| Output
    end

    style Input fill:#e3f2fd
    style Agent fill:#fff3e0
    style Code fill:#f3e5f5
    style Execute fill:#e8f5e9
    style Validation fill:#fce4ec
    style Output fill:#c8e6c9
    style Custom fill:#fff,stroke-dasharray: 5 5
    style LLM fill:#fff,stroke-dasharray: 5 5
</code></pre>

<p>The validation pipeline supports three layers:</p>

<ol>
  <li><strong>Schema validation</strong> (Pydantic): Structural correctness‚Äîtypes, required fields, enum values</li>
  <li><strong>Custom validators</strong> <em>(optional)</em>: Domain-specific rules‚Äîe.g., ‚Äúanalysis date must be after sample creation‚Äù</li>
  <li><strong>LLM-as-judge</strong> <em>(optional)</em>: Semantic validation‚Äîe.g., ‚Äúdoes this hypothesis text make scientific sense?‚Äù</li>
</ol>

<h3 id="learning-mode">Learning Mode</h3>

<p>When <code class="language-plaintext highlighter-rouge">--learn</code> is enabled, the transformer saves:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">transform.py</code>: The generated transformation script</li>
  <li><code class="language-plaintext highlighter-rouge">SKILL.md</code>: Documentation for reuse</li>
</ul>

<p>On subsequent runs with similar instructions, the system can replay the transformation without agent involvement‚Äî<strong>proving it learned</strong>.</p>

<hr />

<h2 id="demo-graph-representations">Demo: Graph Representations</h2>

<h3 id="generating-graphs-from-natural-language">Generating Graphs from Natural Language</h3>

<p>Describe what you want in plain English, and the system generates a complete workflow schema.</p>

<p><img src="assets/gifs/generating-graphs.gif" alt="Generating Graphs" /></p>

<p><strong>What‚Äôs happening:</strong></p>
<ol>
  <li>User describes workflow: ‚ÄúI want to track chemical synthesis experiments with samples, analyses, and hypotheses‚Äù</li>
  <li>LLM generates <code class="language-plaintext highlighter-rouge">WorkflowDefinition</code> with node types, edges, states</li>
  <li>System validates the schema</li>
  <li>User previews the generated structure before creating</li>
</ol>

<h3 id="multiple-views-from-one-graph">Multiple Views from One Graph</h3>

<p>The same instance graph renders in different views‚Äîeach optimized for different tasks.</p>

<p><img src="assets/gifs/views-demo.gif" alt="Views Demo" /></p>

<p><strong>Supported View Styles:</strong></p>

<table>
  <thead>
    <tr>
      <th>Style</th>
      <th>Use Case</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Kanban</strong></td>
      <td>Status-based workflows, drag-and-drop</td>
    </tr>
    <tr>
      <td><strong>Table</strong></td>
      <td>Data analysis, sorting, filtering</td>
    </tr>
    <tr>
      <td><strong>Timeline</strong></td>
      <td>Chronological tracking</td>
    </tr>
    <tr>
      <td><strong>Tree</strong></td>
      <td>Hierarchical relationships (sample lineage)</td>
    </tr>
    <tr>
      <td><strong>Gantt</strong></td>
      <td>Project planning with durations</td>
    </tr>
    <tr>
      <td><strong>Cards</strong></td>
      <td>Visual browsing</td>
    </tr>
    <tr>
      <td><strong>Record</strong></td>
      <td>Master-detail exploration</td>
    </tr>
  </tbody>
</table>

<h3 id="business-logic-state-machines-in-action">Business Logic: State Machines in Action</h3>

<p>State machines enforce workflow rules‚Äîlike ‚Äúa Sample needs at least one Analysis before completion.‚Äù</p>

<p><img src="assets/gifs/state-machine.gif" alt="State Machine Demo" /></p>

<p><strong>How it works:</strong></p>

<ol>
  <li>User tries to mark Sample as ‚ÄúComplete‚Äù</li>
  <li>System checks rules: <code class="language-plaintext highlighter-rouge">requireEdges: [{"edgeType": "HAS_ANALYSIS", "minCount": 1}]</code></li>
  <li>If no Analysis exists ‚Üí transition blocked with helpful message</li>
  <li>User adds Analysis ‚Üí transition succeeds</li>
</ol>

<h3 id="ai-powered-node-generation">AI-Powered Node Generation</h3>

<p>Graphs unlock a powerful pattern for AI: <strong>prediction becomes graph-conditioned generation</strong>.</p>

<p><img src="assets/gifs/ai-node-generation.gif" alt="AI Node Generation" /></p>

<p><img src="assets/gifs/ai-node-generation2.gif" alt="AI Node Generation - Alternate" /></p>

<p><img src="assets/gifs/ai-property-generation.gif" alt="AI Property Generation" /></p>

<p>The insight is simple but profound. Given any node, we can:</p>

<ol>
  <li><strong>Extract its neighborhood</strong>: Traverse edges to gather related nodes</li>
  <li><strong>Build context</strong>: Serialize the local subgraph into a prompt</li>
  <li><strong>Generate</strong>: Ask an LLM to produce something conditioned on that context</li>
</ol>

<p>This pattern generalizes across domains:</p>

<table>
  <thead>
    <tr>
      <th>Use Case</th>
      <th>Neighborhood</th>
      <th>Generation</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Suggest next experiment</strong></td>
      <td>Previous samples + their analyses + outcomes</td>
      <td>New Sample node with parameters</td>
    </tr>
    <tr>
      <td><strong>Generate readable nickname</strong></td>
      <td>Parent samples + analysis types + key results</td>
      <td>Human-friendly identifier like ‚ÄúHigh-Temp-TGA-Batch-3‚Äù</td>
    </tr>
    <tr>
      <td><strong>Draft hypothesis</strong></td>
      <td>Related samples + anomalous analysis results</td>
      <td>Hypothesis node with rationale</td>
    </tr>
    <tr>
      <td><strong>Recommend analysis</strong></td>
      <td>Sample properties + similar samples‚Äô successful analyses</td>
      <td>Analysis node with suggested parameters</td>
    </tr>
  </tbody>
</table>

<p>The abstraction is domain-agnostic:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>generate(
  context = neighborhood(node, depth=2),
  output = NodeType | FieldValue
)
</code></pre></div></div>

<p>Whether you‚Äôre doing materials science, drug discovery, or project management, the same machinery applies. The graph structure tells the model what‚Äôs relevant; the schema constrains what‚Äôs valid.</p>

<hr />

<h2 id="demo-agentic-transformers">Demo: Agentic Transformers</h2>

<h3 id="learning-endpoints">Learning Endpoints</h3>

<p>The transformer allows us to expose an API which is learned from user requests. This allows external services to <strong>push</strong> data into the graph, e.g.
from laboratory equipment, testing rigs, etc., in a permissionless way.</p>

<p><img src="assets/gifs/learning-endpoints.gif" alt="Learning Endpoints" /></p>

<p><strong>The process:</strong></p>

<ol>
  <li>Provide an example input to the transformer, in json format, including any keys that indicate how matching / upserting may occur</li>
  <li>Provide instructions in natural language for the intended effect and output type</li>
  <li>Transformer loops, performing data analysis, doing research on how to do this, until the constraints are satisfied</li>
  <li>Instance graph delta is provided to user</li>
  <li>Once confirmed, the learned transformer code is stored for that endpoint, and this is now a repeatable user-generated API route</li>
</ol>

<p>The key insight: successful validation <strong>proves</strong> the connector works. There‚Äôs no gap between ‚Äúcode that looks right‚Äù and ‚Äúcode that works.‚Äù</p>

<h3 id="learning-connectors">Learning Connectors</h3>

<p>The graph also needs to <strong>pull</strong> information from various 3rd party sources. The transformer allows the system to learn how to connect to any 3rd party
system - agents are trivially able to write this type of code.</p>

<p><img src="assets/gifs/learning-connectors.gif" alt="Learning Connectors" /></p>

<p><strong>The process:</strong></p>

<p>The transformer:</p>
<ol>
  <li>Provide the transformer with urls of external assets, e.g. a wandb link, as well as any secrets required (which are stored in encrypted storage)</li>
  <li>Provide instructions in natural language for the desired output types</li>
  <li>Transformer loops, reading API documentation on the web, writing transformation code, until the constraints are sastified.</li>
  <li>User confirms that the output is correct</li>
  <li>The system can now connect this data source to any node, and the graph will pull in the context for any AI operations</li>
</ol>

<p>TBD - 3rd party pull graph automation, e.g. pull list of projects periodically, create nodes for each new run.</p>

<hr />

<h2 id="chat-graph-native-context-building">Chat: Graph-Native Context Building</h2>

<p>Chat is now a first-class feature in modern applications. But making chat useful requires giving the model relevant context‚Äîand this is where graphs shine.</p>

<p><img src="assets/gifs/chat-demo.gif" alt="Chat Demo" /></p>

<h3 id="the-problem-with-traditional-approaches">The Problem with Traditional Approaches</h3>

<p>In relational databases, building context for an LLM is painful:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- "What analyses have been run on samples related to hypothesis H-007?"</span>
<span class="k">SELECT</span> <span class="n">a</span><span class="p">.</span><span class="o">*</span> <span class="k">FROM</span> <span class="n">analyses</span> <span class="n">a</span>
<span class="k">JOIN</span> <span class="n">sample_analyses</span> <span class="n">sa</span> <span class="k">ON</span> <span class="n">a</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">sa</span><span class="p">.</span><span class="n">analysis_id</span>
<span class="k">JOIN</span> <span class="n">samples</span> <span class="n">s</span> <span class="k">ON</span> <span class="n">sa</span><span class="p">.</span><span class="n">sample_id</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">id</span>
<span class="k">JOIN</span> <span class="n">sample_hypotheses</span> <span class="n">sh</span> <span class="k">ON</span> <span class="n">s</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">sh</span><span class="p">.</span><span class="n">sample_id</span>
<span class="k">WHERE</span> <span class="n">sh</span><span class="p">.</span><span class="n">hypothesis_id</span> <span class="o">=</span> <span class="s1">'H-007'</span>
<span class="c1">-- Plus: figure out which tables exist, what the join keys are,</span>
<span class="c1">-- handle nullable foreign keys, deal with many-to-many tables...</span>
</code></pre></div></div>

<p>Every query requires understanding the schema, writing correct joins, and handling edge cases. This complexity multiplies across domains‚Äîeach new workflow means new tables and new join patterns.</p>

<h3 id="graph-traversal-as-context-assembly">Graph Traversal as Context Assembly</h3>

<p>With graphs, context building becomes declarative traversal:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Same question, graph approach:
</span><span class="n">context</span> <span class="o">=</span> <span class="n">graph</span><span class="p">.</span><span class="n">traverse</span><span class="p">(</span>
    <span class="n">start</span><span class="o">=</span><span class="s">"H-007"</span><span class="p">,</span>
    <span class="n">edges</span><span class="o">=</span><span class="p">[</span><span class="s">"LINKED_TO_HYPOTHESIS"</span><span class="p">,</span> <span class="s">"HAS_ANALYSIS"</span><span class="p">],</span>
    <span class="n">depth</span><span class="o">=</span><span class="mi">2</span>
<span class="p">)</span>
</code></pre></div></div>

<p>The agent doesn‚Äôt need to know about join tables or foreign keys. It just walks the graph.</p>

<h3 id="why-this-matters-for-chat">Why This Matters for Chat</h3>

<p>When a user asks a question, the agent can:</p>

<ol>
  <li><strong>Identify relevant starting nodes</strong> from the question</li>
  <li><strong>Traverse the graph</strong> to gather related context</li>
  <li><strong>Serialize the subgraph</strong> into the prompt</li>
  <li><strong>Generate a grounded response</strong> based on actual data</li>
</ol>

<p>This works regardless of domain. A materials science workflow and a hiring pipeline use the same traversal machinery‚Äîonly the node and edge types differ.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>User: "Why did we reject hypothesis H-007?"

Agent internally:
1. Find node H-007 (type: Hypothesis, status: Rejected)
2. Traverse LINKED_TO_HYPOTHESIS edges ‚Üí find related Samples
3. Traverse HAS_ANALYSIS edges ‚Üí find their Analyses
4. Include rejection_reason field from H-007
5. Generate response grounded in this context
</code></pre></div></div>

<p>The graph structure makes context assembly systematic rather than bespoke.</p>

<hr />

<h2 id="architecture-summary">Architecture Summary</h2>

<pre><code class="language-mermaid">flowchart TB
    subgraph UI["User Interface"]
        Kanban["Kanban"]
        Table["Table"]
        Timeline["Timeline"]
        Tree["Tree"]
        More["..."]
    end

    subgraph Renderer["View Renderer"]
        VR["Traverses graph according to ViewTemplate config"]
    end

    subgraph GraphLayer["Graph Layer"]
        subgraph Schema["Schema Graph"]
            NT["NodeTypes"]
            ET["EdgeTypes"]
            Rules["Rules"]
            VT["ViewTemplates"]
        end
        subgraph Instance["Instance Graph"]
            Nodes["Node instances"]
            Edges["Edge instances"]
            Events["Events"]
        end
        RulesEngine["Rules Engine&lt;br/&gt;&lt;small&gt;Enforces state transitions &amp; constraints&lt;/small&gt;"]
    end

    subgraph TransformerLayer["Agentic Transformer"]
        External["External Data&lt;br/&gt;&lt;small&gt;Notion ¬∑ Drive ¬∑ Excel ¬∑ APIs&lt;/small&gt;"]
        Agent["Claude Agent"]
        Validator["Validator&lt;br/&gt;&lt;small&gt;Pydantic + Custom&lt;/small&gt;"]
    end

    Kanban &amp; Table &amp; Timeline &amp; Tree &amp; More --&gt; VR
    VR --&gt; Schema
    VR --&gt; Instance
    Instance --&gt; RulesEngine
    Schema --&gt; RulesEngine

    External --&gt; Agent
    Agent --&gt; Validator
    Validator --&gt;|"valid"| Instance

    style UI fill:#e3f2fd
    style Renderer fill:#fff3e0
    style GraphLayer fill:#e8f5e9
    style TransformerLayer fill:#fce4ec
</code></pre>

<hr />

<h2 id="whats-missing-workflow-orchestration">What‚Äôs Missing: Workflow Orchestration</h2>

<p>This prototype handles <strong>workflow representation</strong>‚Äîbut not yet <strong>workflow execution</strong>. The gap is significant.</p>

<h3 id="the-representation-vs-execution-gap">The Representation vs. Execution Gap</h3>

<p>Currently, we can:</p>
<ul>
  <li>Define what states nodes can be in</li>
  <li>Specify which transitions are valid</li>
  <li>Enforce rules that block invalid transitions</li>
</ul>

<p>But we cannot yet:</p>
<ul>
  <li>Define <strong>processes</strong> that prescribe how work should flow</li>
  <li>Automatically <strong>trigger actions</strong> when graph state changes</li>
  <li>Assign <strong>tasks</strong> to humans or agents based on process state</li>
</ul>

<h3 id="process-definitions-prescribing-work">Process Definitions: Prescribing Work</h3>

<p>A <strong>process definition</strong> describes a desired flow of state changes through the graph:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">process</span><span class="pi">:</span> <span class="s2">"</span><span class="s">Sample</span><span class="nv"> </span><span class="s">Analysis</span><span class="nv"> </span><span class="s">Pipeline"</span>
<span class="na">steps</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s2">"</span><span class="s">Create</span><span class="nv"> </span><span class="s">Sample"</span>
    <span class="na">creates</span><span class="pi">:</span> <span class="pi">{</span> <span class="nv">type</span><span class="pi">:</span> <span class="nv">Sample</span><span class="pi">,</span> <span class="nv">status</span><span class="pi">:</span> <span class="nv">Draft</span> <span class="pi">}</span>
    <span class="na">assignee</span><span class="pi">:</span> <span class="s">human | agent</span>

  <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s2">"</span><span class="s">Run</span><span class="nv"> </span><span class="s">Initial</span><span class="nv"> </span><span class="s">Analysis"</span>
    <span class="na">requires</span><span class="pi">:</span> <span class="pi">{</span> <span class="nv">type</span><span class="pi">:</span> <span class="nv">Sample</span><span class="pi">,</span> <span class="nv">status</span><span class="pi">:</span> <span class="s2">"</span><span class="s">In</span><span class="nv"> </span><span class="s">Progress"</span> <span class="pi">}</span>
    <span class="na">creates</span><span class="pi">:</span> <span class="pi">{</span> <span class="nv">type</span><span class="pi">:</span> <span class="nv">Analysis</span><span class="pi">,</span> <span class="nv">edge</span><span class="pi">:</span> <span class="nv">HAS_ANALYSIS</span> <span class="pi">}</span>
    <span class="na">assignee</span><span class="pi">:</span> <span class="s">agent</span>  <span class="c1"># AI can trigger instrument</span>

  <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s2">"</span><span class="s">Review</span><span class="nv"> </span><span class="s">Results"</span>
    <span class="na">requires</span><span class="pi">:</span> <span class="pi">{</span> <span class="nv">type</span><span class="pi">:</span> <span class="nv">Analysis</span><span class="pi">,</span> <span class="nv">status</span><span class="pi">:</span> <span class="nv">Complete</span> <span class="pi">}</span>
    <span class="na">transitions</span><span class="pi">:</span> <span class="pi">{</span> <span class="nv">Sample</span><span class="pi">:</span> <span class="s2">"</span><span class="s">In</span><span class="nv"> </span><span class="s">Progress"</span> <span class="nv">‚Üí "Complete"</span> <span class="pi">}</span>
    <span class="na">assignee</span><span class="pi">:</span> <span class="s">human</span>  <span class="c1"># Human reviews before sign-off</span>
</code></pre></div></div>

<p>Each step prescribes:</p>
<ul>
  <li><strong>What must exist</strong> before the step can run (preconditions)</li>
  <li><strong>What gets created or changed</strong> when the step executes (effects)</li>
  <li><strong>Who handles it</strong>: a human or an agent</li>
</ul>

<h3 id="event-driven-orchestration">Event-Driven Orchestration</h3>

<p>The key architectural addition is <strong>reactive execution</strong>: every graph edit triggers evaluation of process state.</p>

<pre><code class="language-mermaid">flowchart LR
    subgraph Triggers["Graph Events"]
        NodeCreated["Node created"]
        StatusChanged["Status changed"]
        EdgeAdded["Edge added"]
    end

    subgraph Engine["Process Engine"]
        Evaluate["Evaluate&lt;br/&gt;Processes"]
    end

    subgraph Actions["Triggered Actions"]
        Human["üë§ Create human task"]
        Agent["ü§ñ Invoke agent"]
        Notify["üìß Send notification"]
        External["üîó Trigger external system"]
    end

    NodeCreated &amp; StatusChanged &amp; EdgeAdded --&gt; Evaluate
    Evaluate --&gt; Human &amp; Agent &amp; Notify &amp; External

    style Triggers fill:#e3f2fd
    style Engine fill:#fff3e0
    style Actions fill:#e8f5e9
</code></pre>

<h3 id="multiple-processes-one-graph">Multiple Processes, One Graph</h3>

<p>A single graph can have multiple process definitions running concurrently:</p>

<table>
  <thead>
    <tr>
      <th>Process</th>
      <th>Concern</th>
      <th>Operates On</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Sample Pipeline</strong></td>
      <td>Core experimental flow</td>
      <td>Sample ‚Üí Analysis ‚Üí Complete</td>
    </tr>
    <tr>
      <td><strong>Quality Review</strong></td>
      <td>Compliance checking</td>
      <td>Any node entering ‚ÄúComplete‚Äù</td>
    </tr>
    <tr>
      <td><strong>Hypothesis Validation</strong></td>
      <td>Scientific method</td>
      <td>Hypothesis + supporting Analyses</td>
    </tr>
  </tbody>
</table>

<p>Each process has its own state machine dynamics, but they share the same underlying graph. A Sample completing its pipeline might simultaneously trigger a quality review process and update hypothesis validation state.</p>

<h3 id="human-agent-task-allocation">Human-Agent Task Allocation</h3>

<p>The process engine assigns tasks based on step configuration:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Step: "Review anomalous results"
  condition: Analysis.result contains anomaly flag
  assignee: human
  ‚Üí Creates task in human's queue

Step: "Run follow-up TGA analysis"
  condition: Previous analysis suggests thermal decomposition
  assignee: agent
  ‚Üí Agent receives instruction, triggers instrument, creates Analysis node
</code></pre></div></div>

<p>This is workflow orchestration in the true sense: not just representing work, but <strong>driving it forward</strong> through a combination of human judgment and agent automation.</p>

<h3 id="why-this-matters">Why This Matters</h3>

<p>Without execution, we have a very nice data structure. With execution, we have a system that:</p>

<ul>
  <li><strong>Guides users</strong> through complex multi-step processes</li>
  <li><strong>Automates routine steps</strong> while keeping humans in the loop for judgment calls</li>
  <li><strong>Tracks progress</strong> across concurrent processes</li>
  <li><strong>Enforces process compliance</strong> through the same rule engine that enforces state validity</li>
</ul>

<p>The graph representation makes this possible‚Äîbut the execution engine makes it useful.</p>

<p>This takes us one step closer to our goal of multi-scale technology development!</p>

<hr />

<p><em>Built by the Reactivy team. For questions or collaboration opportunities, reach out at <a href="mailto:team@reactivy.io">team@reactivy.io</a>.</em></p>


      <footer class="site-footer">
        
          <span class="site-footer-owner"><a href="https://github.com/reactivy/papeete">papeete</a> is maintained by <a href="https://github.com/reactivy">reactivy</a>.</span>
        
        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a>.</span>
      </footer>
    </main>
  </body>
</html>
